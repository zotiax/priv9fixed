local ReGui = loadstring(game:HttpGet('https://raw.githubusercontent.com/depthso/Dear-ReGui/refs/heads/main/ReGui.lua'))()


local Window = ReGui:TabsWindow({
	Title = "core.cc",
	Size = UDim2.fromOffset(300, 200)
}) --> TabSelector & WindowClass



local Names = {"Aim Assist"}

for _, Name in next, Names do
	--// Create tab
	local Tab = Window:CreateTab({Name=Name}) --> Canvas
	Tab:Label({
		Text = ``
	})
	
	if Name == "Aim Assist" then
		local isCamlockEnabled = false
		local camlockTarget = nil
		local isAimAssistEnabled = false
		local smoothnessEnabled = false
		local smoothness = 5
		local shakeEnabled = false
		local shakeX = 5
		local shakeY = 5
		local shakeZ = 5
		local selectedHitbox = "HumanoidRootPart"
		local predictionEnabled = false
		local predictionAmount = 0.001
		local fovEnabled = false
		local fovSize = 100
		local fovColor = Color3.fromRGB(255, 255, 255)
		local fovCircle = nil
		local fovOutline = nil


		
		-- Aim Assist Main Toggle
		local aimAssistCheckbox = Tab:Checkbox({
			Value = false,
			Label = "Enable Aim Assist",
			Callback = function(self, Value)
				isAimAssistEnabled = Value
				
				if not isAimAssistEnabled then
					-- Disable camlock if aim assist is turned off
					game:GetService("RunService"):UnbindFromRenderStep("CamlockLoop")
					camlockTarget = nil
					isCamlockEnabled = false
					print("Aim Assist disabled")
					
					-- Hide FOV circle if it exists
					if fovCircle then
						fovCircle.Visible = false
					end
					if fovOutline then
						fovOutline.Visible = false
					end
				else
					print("Aim Assist enabled")
					
					-- Show FOV circle if enabled
					if fovEnabled then
						if fovCircle then
							fovCircle.Visible = true
						end
						if fovOutline then
							fovOutline.Visible = true
						end
					end
				end
			end,
		})
		
		-- Game Type Selection

		
		-- Hitbox Selection
		Tab:Combo({
			Label = "Target Hitbox",
			Selected = "HumanoidRootPart",
			Items = {
				"Head",
				"UpperTorso",
				"HumanoidRootPart",
				"LowerTorso"
			},
			Callback = function(self, Value)
				selectedHitbox = Value
				print("Selected hitbox: " .. Value)
				
				-- Update camlock behavior if it's currently active
				if isCamlockEnabled and camlockTarget then
					updateCamlockBehavior()
				end
			end
		})
		
		-- FOV Controls
		Tab:Checkbox({
			Value = false,
			Label = "Enable FOV Circle",
			Callback = function(self, Value)
				fovEnabled = Value
				print("FOV Circle " .. (Value and "enabled" or "disabled"))
				
				-- Create FOV circle if it doesn't exist
				if not fovCircle then
					fovCircle = Drawing.new("Circle")
					fovCircle.Thickness = 2
					fovCircle.NumSides = 100
					fovCircle.Radius = fovSize
					fovCircle.Filled = false
					fovCircle.Transparency = 1
					fovCircle.Color = fovColor
					fovCircle.ZIndex = 2
					
					fovOutline = Drawing.new("Circle")
					fovOutline.Thickness = 4
					fovOutline.NumSides = 100
					fovOutline.Radius = fovSize
					fovOutline.Filled = false
					fovOutline.Transparency = 0.5
					fovOutline.Color = Color3.new(0, 0, 0)
					fovOutline.ZIndex = 1
					
					-- Update FOV position on RenderStepped
					game:GetService("RunService").RenderStepped:Connect(function()
						if fovCircle and fovOutline then
							local mousePos = game:GetService("UserInputService"):GetMouseLocation()
							fovCircle.Position = mousePos
							fovOutline.Position = mousePos
							
							fovCircle.Visible = fovEnabled and isAimAssistEnabled
							fovOutline.Visible = fovEnabled and isAimAssistEnabled
						end
					end)
				end
				
				-- Show/hide FOV circle based on toggle
				if fovCircle and fovOutline then
					fovCircle.Visible = Value and isAimAssistEnabled
					fovOutline.Visible = Value and isAimAssistEnabled
				end
				
				-- Update camlock behavior to respect FOV
				if isCamlockEnabled and camlockTarget then
					updateCamlockBehavior()
				end
			end,
		})
		
		Tab:SliderInt({
			Label = "FOV Size",
			Value = 100,
			Minimum = 10,
			Maximum = 500,
			Callback = function(self, Value)
				fovSize = Value
				print("FOV Size set to: " .. Value)
				
				-- Update FOV circle size
				if fovCircle then
					fovCircle.Radius = Value
				end
				if fovOutline then
					fovOutline.Radius = Value
				end
			end
		})
		
		Tab:DragColor3({
			Value = Color3.fromRGB(255, 255, 255),
			Label = "FOV Color",
			Callback = function(self, Value)
				fovColor = Value
				print("FOV Color updated")
				
				-- Update FOV circle color
				if fovCircle then
					fovCircle.Color = Value
				end
			end
		})
		
		-- Smoothness Controls
		Tab:Checkbox({
			Value = false,
			Label = "Enable Smoothness",
			Callback = function(self, Value)
				smoothnessEnabled = Value
				print("Smoothness " .. (Value and "enabled" or "disabled"))
				
				-- Update camlock behavior if it's currently active
				if isCamlockEnabled and camlockTarget then
					updateCamlockBehavior()
				end
			end,
		})
		
		Tab:SliderInt({
			Label = "Smoothness",
			Value = 5,
			Minimum = 1,
			Maximum = 1000,
			Callback = function(self, Value)
				smoothness = Value
				print("Smoothness set to: " .. Value)
			end
		})
		
		-- Prediction Controls
		Tab:Checkbox({
			Value = false,
			Label = "Enable Prediction",
			Callback = function(self, Value)
				predictionEnabled = Value
				print("Prediction " .. (Value and "enabled" or "disabled"))
				
				-- Update camlock behavior if it's currently active
				if isCamlockEnabled and camlockTarget then
					updateCamlockBehavior()
				end
			end,
		})
		
		Tab:SliderFloat({
			Label = "Prediction Amount",
			Value = 0.001,
			Minimum = 0.001,
			Maximum = 1.0,
			Format = "%.3f",
			Callback = function(self, Value)
				predictionAmount = Value
				print("Prediction set to: " .. Value)
				
				-- Update camlock behavior if it's currently active
				if isCamlockEnabled and camlockTarget then
					updateCamlockBehavior()
				end
			end
		})
		
		-- Shake Controls
		Tab:Checkbox({
			Value = false,
			Label = "Enable Shake",
			Callback = function(self, Value)
				shakeEnabled = Value
				print("Shake " .. (Value and "enabled" or "disabled"))
				
				-- Update camlock behavior if it's currently active
				if isCamlockEnabled and camlockTarget then
					updateCamlockBehavior()
				end
			end,
		})
		
		Tab:SliderInt({
			Label = "Shake X",
			Value = 5,
			Minimum = 0,
			Maximum = 50,
			Callback = function(self, Value)
				shakeX = Value
				print("Shake X set to: " .. Value)
			end
		})
		
		Tab:SliderInt({
			Label = "Shake Y",
			Value = 5,
			Minimum = 0,
			Maximum = 50,
			Callback = function(self, Value)
				shakeY = Value
				print("Shake Y set to: " .. Value)
			end
		})
		
		Tab:SliderInt({
			Label = "Shake Z",
			Value = 5,
			Minimum = 0,
			Maximum = 50,
			Callback = function(self, Value)
				shakeZ = Value
				print("Shake Z set to: " .. Value)
			end
		})
		
		-- Function to get target part based on game type
		local function getTargetPart(player)
			if not player or not player.Character then return nil end
			
			if isRoboxRivals then
				-- For Robox Rivals, check for the specific character model structure
				if player.Character:FindFirstChild("Torso") then
					return player.Character:FindFirstChild("Torso")
				elseif player.Character:FindFirstChild("UpperTorso") then
					return player.Character:FindFirstChild("UpperTorso")
				end
			else
				-- Standard Roblox character structure
				if player.Character:FindFirstChild(selectedHitbox) then
					return player.Character:FindFirstChild(selectedHitbox)
				end
			end
			
			return nil
		end
		
		-- Function to check if target is within FOV
		local function isWithinFOV(targetPosition)
			if not fovEnabled then return true end
			
			local camera = workspace.CurrentCamera
			local screenPoint = camera:WorldToScreenPoint(targetPosition)
			
			if screenPoint.Z < 0 then return false end
			
			local mousePosition = game:GetService("UserInputService"):GetMouseLocation()
			local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - mousePosition).Magnitude
			
			return distance <= fovSize
		end
		
		-- Function to update camlock behavior
		function updateCamlockBehavior()  -- Made function global for access
			game:GetService("RunService"):UnbindFromRenderStep("CamlockLoop")
			
			if camlockTarget then
				game:GetService("RunService"):BindToRenderStep("CamlockLoop", Enum.RenderPriority.Camera.Value, function()
					local targetPart = getTargetPart(camlockTarget)
					
					if targetPart then
						local camera = workspace.CurrentCamera
						local targetPos = targetPart.Position
						
						-- Apply prediction if enabled
						if predictionEnabled and targetPart:IsA("BasePart") then
							targetPos = targetPos + (targetPart.Velocity * predictionAmount)
						end
						
						-- Check if target is within FOV
						if not isWithinFOV(targetPos) then
							return
						end
						
						-- Apply shake if enabled
						if shakeEnabled then
							targetPos = targetPos + Vector3.new(
								math.random(-shakeX, shakeX) / 100,
								math.random(-shakeY, shakeY) / 100,
								math.random(-shakeZ, shakeZ) / 100
							)
						end
						
						if smoothnessEnabled then
							-- Apply smoothness
							local currentCFrame = camera.CFrame
							local targetCFrame = CFrame.new(currentCFrame.Position, targetPos)
							
							-- Calculate smooth interpolation factor
							local smoothFactor = 1 - (1 / smoothness)
							
							-- Get current and target look vectors
							local currentLook = currentCFrame.LookVector
							local targetLook = (targetPos - currentCFrame.Position).Unit
							
							-- Apply smoothing by lerping between current and target look vectors
							local smoothLook = currentLook:Lerp(targetLook, 1 - smoothFactor)
							
							-- Create new CFrame with smoothed look vector
							camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + smoothLook)
						else
							-- Direct camera lock without smoothing
							camera.CFrame = CFrame.new(camera.CFrame.Position, targetPos)
						end
					end
				end)
			end
		end
		
		-- Camlock Keybind
		Tab:Keybind({
			Label = "Camlock Keybind",
			Value = Enum.KeyCode.Q,
			OnKeybindSet = function(self, KeyId)
				warn("[OnKeybindSet] .Value ->", KeyId)
			end,
			Callback = function(self, KeyId)
				-- Only toggle camlock if aim assist is enabled
				if not isAimAssistEnabled then
					print("Aim Assist is disabled. Enable it first.")
					return
				end
				
				isCamlockEnabled = not isCamlockEnabled
				
				if isCamlockEnabled then
					-- Find closest player to mouse cursor
					local closestPlayer = nil
					local closestDistance = math.huge
					local localPlayer = game.Players.LocalPlayer
					local mouse = localPlayer:GetMouse()
					local camera = workspace.CurrentCamera
					
					for _, player in pairs(game.Players:GetPlayers()) do
						if player ~= localPlayer then
							local targetPart = getTargetPart(player)
							
							if targetPart then
								-- Get 2D screen position of player
								local screenPoint = camera:WorldToScreenPoint(targetPart.Position)
								
								-- Only consider players in front of the camera
								if screenPoint.Z > 0 then
									-- Calculate distance from mouse to player on screen
									local mouseDistance = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
									
									-- Check if player is within FOV if enabled
									if (not fovEnabled or mouseDistance <= fovSize) and mouseDistance < closestDistance then
										closestDistance = mouseDistance
										closestPlayer = player
									end
								end
							end
						end
					end
					
					camlockTarget = closestPlayer
					print("Camlock enabled on: " .. (camlockTarget and camlockTarget.Name or "No target found"))
					
					-- Start the camlock loop
					if camlockTarget then
						updateCamlockBehavior()
					end
				else
					-- Disable camlock
					game:GetService("RunService"):UnbindFromRenderStep("CamlockLoop")
					camlockTarget = nil
					print("Camlock disabled")
				end
			end,
		})
	end
end

-- Create Visuals tab
local Tab = Window:CreateTab({Name="Visuals"}) --> Canvas
Tab:Label({
	Text = ``
})

-- ESP Section
Tab:Label({
	Text = "Esp"
})

local boxEspEnabled = false
local nameEspEnabled = false
local healthbarEnabled = false  -- New variable for healthbar
local toolEspEnabled = false    -- New variable for tool ESP
local distanceEspEnabled = false -- New variable for distance ESP
local skeletonEspEnabled = false -- New variable for skeleton ESP
local chamsEnabled = false      -- New variable for chams
local highlightEnabled = false  -- New variable for highlight ESP
local nameEspMode = "Username" -- "Username" or "DisplayName"
local espColor = Color3.fromRGB(255, 255, 255)
local nameEspColor = Color3.fromRGB(255, 255, 255) -- Separate color for name ESP
local healthbarColor = Color3.fromRGB(0, 255, 0)  -- Color for full health
local lowHealthColor = Color3.fromRGB(255, 0, 0)  -- Color for low health
local skeletonColor = Color3.fromRGB(255, 255, 255) -- Color for skeleton ESP
local chamsColor = Color3.fromRGB(0, 170, 255)    -- Color for chams
local highlightColor = Color3.fromRGB(255, 0, 255) -- Color for highlights
local chamsTransparency = 0.5   -- Transparency for chams
local highlightTransparency = 0.5 -- Transparency for highlights
local espRenderConnection = nil
local espDrawings = {}
local chamsDrawings = {}  -- Store chams drawings instead of highlights
local highlights = {}     -- Store highlight instances

-- Function to clean up ESP
local function cleanupEsp()
	if espRenderConnection then
		espRenderConnection:Disconnect()
		espRenderConnection = nil
	end
	
	for _, drawing in pairs(espDrawings) do
		if drawing.Remove then
			drawing:Remove()
		end
	end
	espDrawings = {}
	
	-- Remove chams
	for _, drawingSet in pairs(chamsDrawings) do
		for _, drawing in pairs(drawingSet) do
			if drawing.Remove then
				drawing:Remove()
			end
		end
	end
	chamsDrawings = {}
	
	-- Remove highlights
	for _, highlight in pairs(highlights) do
		if highlight then
			highlight:Destroy()
		end
	end
	highlights = {}
end

-- Function to create chams for a character using Drawing API
local function createChams(character, player)
	if not character then return end
	
	-- Remove existing chams for this player
	if chamsDrawings[player.Name] then
		for _, drawing in pairs(chamsDrawings[player.Name]) do
			if drawing.Remove then
				drawing:Remove()
			end
		end
	end
	
	chamsDrawings[player.Name] = {}
	
	-- Create chams for each part
	for _, part in pairs(character:GetChildren()) do
		if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
			-- Get corners of the part in 3D space
			local size = part.Size
			local cf = part.CFrame
			
			local corners = {
				cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2), -- Bottom front left
				cf * CFrame.new(-size.X/2, -size.Y/2, size.Z/2),  -- Bottom back left
				cf * CFrame.new(size.X/2, -size.Y/2, size.Z/2),   -- Bottom back right
				cf * CFrame.new(size.X/2, -size.Y/2, -size.Z/2),  -- Bottom front right
				cf * CFrame.new(-size.X/2, size.Y/2, -size.Z/2),  -- Top front left
				cf * CFrame.new(-size.X/2, size.Y/2, size.Z/2),   -- Top back left
				cf * CFrame.new(size.X/2, size.Y/2, size.Z/2),    -- Top back right
				cf * CFrame.new(size.X/2, size.Y/2, -size.Z/2)    -- Top front right
			}
			
			-- Define the edges of the cube (pairs of corner indices)
			local edges = {
				{1, 2}, {2, 3}, {3, 4}, {4, 1}, -- Bottom face
				{5, 6}, {6, 7}, {7, 8}, {8, 5}, -- Top face
				{1, 5}, {2, 6}, {3, 7}, {4, 8}  -- Connecting edges
			}
			
			-- Create a drawing for each edge
			for _, edge in ipairs(edges) do
				local line = Drawing.new("Line")
				line.Visible = false  -- Will be set to true during rendering if visible
				line.Transparency = 1 - chamsTransparency
				line.Color = chamsColor
				line.Thickness = 1
				
				table.insert(chamsDrawings[player.Name], line)
			end
			
			-- Create quad drawings for each face
			local faces = {
				{1, 2, 3, 4}, -- Bottom
				{5, 6, 7, 8}, -- Top
				{1, 2, 6, 5}, -- Left
				{3, 4, 8, 7}, -- Right
				{2, 3, 7, 6}, -- Back
				{1, 4, 8, 5}  -- Front
			}
			
			for _, face in ipairs(faces) do
				local quad = Drawing.new("Quad")
				quad.Visible = false  -- Will be set to true during rendering if visible
				quad.Transparency = chamsTransparency
				quad.Color = chamsColor
				quad.Filled = true
				
				table.insert(chamsDrawings[player.Name], quad)
			end
		end
	end
end

-- Function to create or update highlights for a character
local function updateHighlight(character, player)
	if not character then return end
	
	-- Remove existing highlight for this player
	if highlights[player.Name] and highlights[player.Name].Parent then
		highlights[player.Name]:Destroy()
		highlights[player.Name] = nil
	end
	
	-- Create new highlight
	local highlight = Instance.new("Highlight")
	highlight.FillColor = highlightColor
	highlight.OutlineColor = highlightColor
	highlight.FillTransparency = highlightTransparency
	highlight.OutlineTransparency = 0.2
	highlight.Adornee = character
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Parent = character
	
	highlights[player.Name] = highlight
end

-- Function to update ESP rendering
local function updateEspRendering()
	-- Clean up existing connection
	if espRenderConnection then
		espRenderConnection:Disconnect()
	end
	
	espRenderConnection = game:GetService("RunService").RenderStepped:Connect(function()
		-- Clear old ESP
		for _, drawing in pairs(espDrawings) do
			if drawing.Remove then
				drawing:Remove()
			end
		end
		espDrawings = {}
		
		-- Update chams visibility
		for playerName, drawingSet in pairs(chamsDrawings) do
			for _, drawing in pairs(drawingSet) do
				drawing.Visible = false
			end
		end
		
		-- Draw new ESP elements
		local localPlayer = game.Players.LocalPlayer
		local camera = workspace.CurrentCamera
		
		for _, player in pairs(game.Players:GetPlayers()) do
			if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
				local character = player.Character
				local humanoid = character:FindFirstChild("Humanoid")
				local rootPart = character:FindFirstChild("HumanoidRootPart")
				
				-- Update highlight if enabled
				if highlightEnabled then
					updateHighlight(character, player)
				elseif highlights[player.Name] then
					highlights[player.Name]:Destroy()
					highlights[player.Name] = nil
				end
				
				-- Get character bounds
				local minX, minY, minZ = math.huge, math.huge, math.huge
				local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
				
				for _, part in pairs(character:GetChildren()) do
					if part:IsA("BasePart") then
						local size = part.Size
						local pos = part.Position
						
						minX = math.min(minX, pos.X - size.X/2)
						minY = math.min(minY, pos.Y - size.Y/2)
						minZ = math.min(minZ, pos.Z - size.Z/2)
						
						maxX = math.max(maxX, pos.X + size.X/2)
						maxY = math.max(maxY, pos.Y + size.Y/2)
						maxZ = math.max(maxZ, pos.Z + size.Z/2)
					end
				end
				
				-- Calculate corners of the bounding box
				local corners = {
					Vector3.new(minX, minY, minZ),
					Vector3.new(minX, minY, maxZ),
					Vector3.new(minX, maxY, minZ),
					Vector3.new(minX, maxY, maxZ),
					Vector3.new(maxX, minY, minZ),
					Vector3.new(maxX, minY, maxZ),
					Vector3.new(maxX, maxY, minZ),
					Vector3.new(maxX, maxY, maxZ)
				}
				
				-- Convert corners to screen points
				local screenPoints = {}
				local onScreen = false
				
				for _, corner in ipairs(corners) do
					local screenPoint, visible = camera:WorldToViewportPoint(corner)
					if visible then
						onScreen = true
						table.insert(screenPoints, Vector2.new(screenPoint.X, screenPoint.Y))
					end
				end
				
				-- Update chams if enabled
				if chamsEnabled then
					-- Create chams if they don't exist for this player
					if not chamsDrawings[player.Name] then
						createChams(character, player)
					end
					
					-- Update chams visibility and positions
					if chamsDrawings[player.Name] then
						local drawingIndex = 1
						
						-- Update each part's chams
						for _, part in pairs(character:GetChildren()) do
							if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
								local size = part.Size
								local cf = part.CFrame
								
								-- Get corners of the part in 3D space
								local corners = {
									cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2).Position, -- Bottom front left
									cf * CFrame.new(-size.X/2, -size.Y/2, size.Z/2).Position,  -- Bottom back left
									cf * CFrame.new(size.X/2, -size.Y/2, size.Z/2).Position,   -- Bottom back right
									cf * CFrame.new(size.X/2, -size.Y/2, -size.Z/2).Position,  -- Bottom front right
									cf * CFrame.new(-size.X/2, size.Y/2, -size.Z/2).Position,  -- Top front left
									cf * CFrame.new(-size.X/2, size.Y/2, size.Z/2).Position,   -- Top back left
									cf * CFrame.new(size.X/2, size.Y/2, size.Z/2).Position,    -- Top back right
									cf * CFrame.new(size.X/2, size.Y/2, -size.Z/2).Position    -- Top front right
								}
								
								-- Convert corners to screen points
								local screenCorners = {}
								local partVisible = false
								
								for _, corner in ipairs(corners) do
									local screenPoint, visible = camera:WorldToViewportPoint(corner)
									if visible then
										partVisible = true
										table.insert(screenCorners, Vector2.new(screenPoint.X, screenPoint.Y))
									else
										table.insert(screenCorners, nil)
									end
								end
								
								-- Update edges if part is visible
								if partVisible then
									local edges = {
										{1, 2}, {2, 3}, {3, 4}, {4, 1}, -- Bottom face
										{5, 6}, {6, 7}, {7, 8}, {8, 5}, -- Top face
										{1, 5}, {2, 6}, {3, 7}, {4, 8}  -- Connecting edges
									}
									
									for _, edge in ipairs(edges) do
										if drawingIndex <= #chamsDrawings[player.Name] and 
										   screenCorners[edge[1]] and screenCorners[edge[2]] then
											local line = chamsDrawings[player.Name][drawingIndex]
											line.From = screenCorners[edge[1]]
											line.To = screenCorners[edge[2]]
											line.Visible = true
											line.Color = chamsColor
											line.Transparency = 1 - chamsTransparency
											drawingIndex = drawingIndex + 1
										else
											drawingIndex = drawingIndex + 1
										end
									end
									
									-- Update faces
									local faces = {
										{1, 2, 3, 4}, -- Bottom
										{5, 6, 7, 8}, -- Top
										{1, 2, 6, 5}, -- Left
										{3, 4, 8, 7}, -- Right
										{2, 3, 7, 6}, -- Back
										{1, 4, 8, 5}  -- Front
									}
									
									for _, face in ipairs(faces) do
										if drawingIndex <= #chamsDrawings[player.Name] and
										   screenCorners[face[1]] and screenCorners[face[2]] and
										   screenCorners[face[3]] and screenCorners[face[4]] then
											local quad = chamsDrawings[player.Name][drawingIndex]
											quad.PointA = screenCorners[face[1]]
											quad.PointB = screenCorners[face[2]]
											quad.PointC = screenCorners[face[3]]
											quad.PointD = screenCorners[face[4]]
											quad.Visible = true
											quad.Color = chamsColor
											quad.Transparency = chamsTransparency
											drawingIndex = drawingIndex + 1
										else
											drawingIndex = drawingIndex + 1
										end
									end
								else
									-- Skip drawings for invisible parts
									drawingIndex = drawingIndex + 18 -- 12 edges + 6 faces
								end
							end
						end
					end
				end
				
				if onScreen and #screenPoints > 0 then
					-- Find the bounds of the 2D box
					local minX, minY = math.huge, math.huge
					local maxX, maxY = -math.huge, -math.huge
					
					for _, point in ipairs(screenPoints) do
						minX = math.min(minX, point.X)
						minY = math.min(minY, point.Y)
						maxX = math.max(maxX, point.X)
						maxY = math.max(maxY, point.Y)
					end
					
					local boxWidth = maxX - minX
					local boxHeight = maxY - minY
					
					-- Calculate distance if needed
					local distance = 0
					if distanceEspEnabled and rootPart then
						distance = math.floor((rootPart.Position - camera.CFrame.Position).Magnitude)
					end
					
					-- Draw box ESP if enabled
					if boxEspEnabled then
						-- Create box outline (black)
						local boxOutline = Drawing.new("Square")
						boxOutline.Visible = true
						boxOutline.Transparency = 1
						boxOutline.Color = Color3.new(0, 0, 0)
						boxOutline.Thickness = 3
						boxOutline.Size = Vector2.new(boxWidth, boxHeight)
						boxOutline.Position = Vector2.new(minX, minY)
						boxOutline.Filled = false
						table.insert(espDrawings, boxOutline)
						
						-- Create box
						local box = Drawing.new("Square")
						box.Visible = true
						box.Transparency = 1
						box.Color = espColor
						box.Thickness = 1
						box.Size = Vector2.new(boxWidth, boxHeight)
						box.Position = Vector2.new(minX, minY)
						box.Filled = false
						table.insert(espDrawings, box)
					end
					
					-- Draw skeleton ESP if enabled
					if skeletonEspEnabled then
						-- Define joint connections for skeleton
						local joints = {
							-- Torso to head
							{character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso"), character:FindFirstChild("Head")},
							
							-- Arms
							{character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso"), character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftUpperArm")},
							{character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso"), character:FindFirstChild("Right Arm") or character:FindFirstChild("RightUpperArm")},
							
							-- Legs
							{character:FindFirstChild("Torso") or character:FindFirstChild("LowerTorso"), character:FindFirstChild("Left Leg") or character:FindFirstChild("LeftUpperLeg")},
							{character:FindFirstChild("Torso") or character:FindFirstChild("LowerTorso"), character:FindFirstChild("Right Leg") or character:FindFirstChild("RightUpperLeg")},
							
							-- R15 additional connections
							{character:FindFirstChild("LeftUpperArm"), character:FindFirstChild("LeftLowerArm")},
							{character:FindFirstChild("LeftLowerArm"), character:FindFirstChild("LeftHand")},
							{character:FindFirstChild("RightUpperArm"), character:FindFirstChild("RightLowerArm")},
							{character:FindFirstChild("RightLowerArm"), character:FindFirstChild("RightHand")},
							{character:FindFirstChild("LeftUpperLeg"), character:FindFirstChild("LeftLowerLeg")},
							{character:FindFirstChild("LeftLowerLeg"), character:FindFirstChild("LeftFoot")},
							{character:FindFirstChild("RightUpperLeg"), character:FindFirstChild("RightLowerLeg")},
							{character:FindFirstChild("RightLowerLeg"), character:FindFirstChild("RightFoot")},
							{character:FindFirstChild("UpperTorso"), character:FindFirstChild("LowerTorso")},
						}
						
						-- Draw lines between joints
						for _, joint in ipairs(joints) do
							local part1, part2 = joint[1], joint[2]
							
							if part1 and part2 then
								local pos1, vis1 = camera:WorldToViewportPoint(part1.Position)
								local pos2, vis2 = camera:WorldToViewportPoint(part2.Position)
								
								if vis1 and vis2 then
									-- Create line outline
									local lineOutline = Drawing.new("Line")
									lineOutline.Visible = true
									lineOutline.Transparency = 1
									lineOutline.Color = Color3.new(0, 0, 0)
									lineOutline.Thickness = 3
									lineOutline.From = Vector2.new(pos1.X, pos1.Y)
									lineOutline.To = Vector2.new(pos2.X, pos2.Y)
									table.insert(espDrawings, lineOutline)
									
									-- Create line
									local line = Drawing.new("Line")
									line.Visible = true
									line.Transparency = 1
									line.Color = skeletonColor
									line.Thickness = 1
									line.From = Vector2.new(pos1.X, pos1.Y)
									line.To = Vector2.new(pos2.X, pos2.Y)
									table.insert(espDrawings, line)
								end
							end
						end
					end
					
					-- Draw name ESP if enabled
					if nameEspEnabled then
						-- Determine which name to display based on mode
						local displayText
						if nameEspMode == "Username" then
							displayText = player.Name
						else -- "DisplayName"
							displayText = player.DisplayName
						end
						
						-- Create name text outline
						local textOutline = Drawing.new("Text")
						textOutline.Visible = true
						textOutline.Transparency = 1
						textOutline.Color = Color3.new(0, 0, 0)
						textOutline.Text = displayText
						textOutline.Size = 18
						textOutline.Center = true
						textOutline.Outline = true
						textOutline.OutlineColor = Color3.new(0, 0, 0)
						textOutline.Position = Vector2.new(minX + boxWidth/2, minY - 20)
						table.insert(espDrawings, textOutline)
						
						-- Create name text
						local text = Drawing.new("Text")
						text.Visible = true
						text.Transparency = 1
						text.Color = nameEspColor -- Use nameEspColor instead of espColor
						text.Text = displayText
						text.Size = 18
						text.Center = true
						text.Outline = false
						text.Position = Vector2.new(minX + boxWidth/2, minY - 20)
						table.insert(espDrawings, text)
					end
					
					-- Draw healthbar if enabled
					if healthbarEnabled and humanoid then
						local health = humanoid.Health
						local maxHealth = humanoid.MaxHealth
						local healthPercentage = health / maxHealth
						
						-- Calculate healthbar dimensions - make it skinnier
						local barWidth = 2  -- Reduced from 5 to 3
						local barHeight = boxHeight
						local filledHeight = barHeight * healthPercentage
						
						-- Interpolate color based on health percentage (green to red)
						local healthColor = healthbarColor:Lerp(lowHealthColor, 1 - healthPercentage)
						
						-- Create healthbar background (black) - now on the left side
						local healthBarBackground = Drawing.new("Square")
						healthBarBackground.Visible = true
						healthBarBackground.Transparency = 1
						healthBarBackground.Color = Color3.new(0, 0, 0)
						healthBarBackground.Thickness = 1
						healthBarBackground.Size = Vector2.new(barWidth + 2, barHeight + 2)
						healthBarBackground.Position = Vector2.new(minX - barWidth - 7, minY - 1)
						healthBarBackground.Filled = true
						table.insert(espDrawings, healthBarBackground)
						
						-- Create healthbar - now on the left side
						local healthBar = Drawing.new("Square")
						healthBar.Visible = true
						healthBar.Transparency = 1
						healthBar.Color = healthColor
						healthBar.Thickness = 1
						healthBar.Size = Vector2.new(barWidth, filledHeight)
						healthBar.Position = Vector2.new(minX - barWidth - 6, maxY - filledHeight)
						healthBar.Filled = true
						table.insert(espDrawings, healthBar)
						
						-- Create health text - now at the top left of the healthbar
						local healthText = Drawing.new("Text")
						healthText.Visible = true
						healthText.Transparency = 1
						healthText.Color = Color3.new(1, 1, 1)
						healthText.Text = math.floor(health) .. "/" .. math.floor(maxHealth)
						healthText.Size = 14
						healthText.Center = false
						healthText.Outline = true
						healthText.OutlineColor = Color3.new(0, 0, 0)
						healthText.Position = Vector2.new(minX - barWidth - 45, minY - 5)  -- Moved to top left of healthbar
						table.insert(espDrawings, healthText)
					end
					
					-- Draw tool ESP if enabled
					if toolEspEnabled then
						local tool = character:FindFirstChildOfClass("Tool")
						local toolName = tool and tool.Name or "None"
						
						-- Create tool text
						local toolText = Drawing.new("Text")
						toolText.Visible = true
						toolText.Transparency = 1
						toolText.Color = Color3.new(1, 1, 1)
						toolText.Text = "[" .. toolName .. "]"
						toolText.Size = 16
						toolText.Center = true
						toolText.Outline = true
						toolText.OutlineColor = Color3.new(0, 0, 0)
						toolText.Position = Vector2.new(minX + boxWidth/2, maxY + 5)
						table.insert(espDrawings, toolText)
					end
					
					-- Draw distance ESP if enabled
					if distanceEspEnabled then
						-- Create distance text
						local distanceText = Drawing.new("Text")
						distanceText.Visible = true
						distanceText.Transparency = 1
						distanceText.Color = Color3.new(1, 1, 1)
						distanceText.Text = distance .. "m"
						distanceText.Size = 16
						distanceText.Center = true
						distanceText.Outline = true
						distanceText.OutlineColor = Color3.new(0, 0, 0)
						distanceText.Position = Vector2.new(minX + boxWidth/2, maxY + (toolEspEnabled and 25 or 5))
						table.insert(espDrawings, distanceText)
					end
				end
			end
		end
	end)
end

-- Box ESP Toggle
Tab:Checkbox({
	Value = false,
	Label = "Box ESP",
	Callback = function(self, Value)
		boxEspEnabled = Value
		
		if boxEspEnabled or nameEspEnabled or healthbarEnabled or toolEspEnabled or distanceEspEnabled or skeletonEspEnabled or chamsEnabled or highlightEnabled then
			-- Start ESP rendering if any ESP feature is enabled
			updateEspRendering()
		else
			-- Clean up ESP if all features are disabled
			cleanupEsp()
		end
	end,
})

-- Name ESP Toggle
Tab:Checkbox({
	Value = false,
	Label = "Name ESP",
	Callback = function(self, Value)
		nameEspEnabled = Value
		
		if boxEspEnabled or nameEspEnabled or healthbarEnabled or toolEspEnabled or distanceEspEnabled or skeletonEspEnabled or chamsEnabled or highlightEnabled then
			-- Start ESP rendering if any ESP feature is enabled
			updateEspRendering()
		else
			-- Clean up ESP if all features are disabled
			cleanupEsp()
		end
	end,
})

-- Healthbar Toggle
Tab:Checkbox({
	Value = false,
	Label = "Health Bar",
	Callback = function(self, Value)
		healthbarEnabled = Value
		
		if boxEspEnabled or nameEspEnabled or healthbarEnabled or toolEspEnabled or distanceEspEnabled or skeletonEspEnabled or chamsEnabled or highlightEnabled then
			-- Start ESP rendering if any ESP feature is enabled
			updateEspRendering()
		else
			-- Clean up ESP if all features are disabled
			cleanupEsp()
		end
	end,
})

-- Tool ESP Toggle
Tab:Checkbox({
	Value = false,
	Label = "Tool ESP",
	Callback = function(self, Value)
		toolEspEnabled = Value
		
		if boxEspEnabled or nameEspEnabled or healthbarEnabled or toolEspEnabled or distanceEspEnabled or skeletonEspEnabled or chamsEnabled or highlightEnabled then
			-- Start ESP rendering if any ESP feature is enabled
			updateEspRendering()
		else
			-- Clean up ESP if all features are disabled
			cleanupEsp()
		end
	end,
})

-- Distance ESP Toggle
Tab:Checkbox({
	Value = false,
	Label = "Distance ESP",
	Callback = function(self, Value)
		distanceEspEnabled = Value
		
		if boxEspEnabled or nameEspEnabled or healthbarEnabled or toolEspEnabled or distanceEspEnabled or skeletonEspEnabled or chamsEnabled or highlightEnabled then
			-- Start ESP rendering if any ESP feature is enabled
			updateEspRendering()
		else
			-- Clean up ESP if all features are disabled
			cleanupEsp()
		end
	end,
})

-- Skeleton ESP Toggle
Tab:Checkbox({
	Value = false,
	Label = "Skeleton ESP",
	Callback = function(self, Value)
		skeletonEspEnabled = Value
		
		if boxEspEnabled or nameEspEnabled or healthbarEnabled or toolEspEnabled or distanceEspEnabled or skeletonEspEnabled or chamsEnabled or highlightEnabled then
			-- Start ESP rendering if any ESP feature is enabled
			updateEspRendering()
		else
			-- Clean up ESP if all features are disabled
			cleanupEsp()
		end
	end,
})

-- Chams Toggle
Tab:Checkbox({
	Value = false,
	Label = "Chams",
	Callback = function(self, Value)
		chamsEnabled = Value
		
		if boxEspEnabled or nameEspEnabled or healthbarEnabled or toolEspEnabled or distanceEspEnabled or skeletonEspEnabled or chamsEnabled or highlightEnabled then
			-- Start ESP rendering if any ESP feature is enabled
			updateEspRendering()
		else
			-- Clean up ESP if all features are disabled
			cleanupEsp()
		end
	end,
})

-- Highlight Toggle
Tab:Checkbox({
	Value = false,
	Label = "Highlight",
	Callback = function(self, Value)
		highlightEnabled = Value
		
		if boxEspEnabled or nameEspEnabled or healthbarEnabled or toolEspEnabled or distanceEspEnabled or skeletonEspEnabled or chamsEnabled or highlightEnabled then
			-- Start ESP rendering if any ESP feature is enabled
			updateEspRendering()
		else
			-- Clean up ESP if all features are disabled
			cleanupEsp()
		end
	end,
})

-- ESP Checks Combo
Tab:Combo({
	Value = "All",
	Label = "ESP Checks",
	Items = {"All", "Enemies", "Teammates", "Custom"},
	Callback = function(self, Value)
		espCheckMode = Value
	end
})

-- Team Check Toggle
Tab:Checkbox({
	Value = false,
	Label = "Team Check",
	Callback = function(self, Value)
		teamCheckEnabled = Value
	end,
})

-- Name ESP Mode Combo
Tab:Combo({
	Value = "Username",
	Label = "Name ESP Mode",
	Items = {"Username", "DisplayName"},
	Callback = function(self, Value)
		nameEspMode = Value
	end
})
-- Colors Section

-- Create World tab for visual settings
local WorldTab = Window:CreateTab({Name="World"})

WorldTab:Label({
	Text = "World Visual Settings"
})

-- World Tint Color Picker
WorldTab:DragColor3({
	Value = Color3.fromRGB(255, 255, 255),
	Label = "World Tint Color",
	Callback = function(self, Value)
		worldTintColor = Value
		game.Lighting.Ambient = Value
		game.Lighting.OutdoorAmbient = Value
	end
})

-- Indoor Ambience Color
WorldTab:DragColor3({
	Value = Color3.fromRGB(127, 127, 127),
	Label = "Indoor Ambience Color",
	Callback = function(self, Value)
		indoorAmbienceColor = Value
		game.Lighting.Ambient = Value
	end
})

-- Outdoor Ambience Color
WorldTab:DragColor3({
	Value = Color3.fromRGB(127, 127, 127),
	Label = "Outdoor Ambience Color",
	Callback = function(self, Value)
		outdoorAmbienceColor = Value
		game.Lighting.OutdoorAmbient = Value
	end
})

-- Fog Toggle
WorldTab:Checkbox({
	Value = false,
	Label = "Enable Fog",
	Callback = function(self, Value)
		fogEnabled = Value
		game.Lighting.FogEnd = Value and fogEndValue or 100000
		game.Lighting.FogStart = Value and fogStartValue or 0
		game.Lighting.FogColor = Value and fogColor or Color3.fromRGB(192, 192, 192)
	end
})

-- Fog Color
WorldTab:DragColor3({
	Value = Color3.fromRGB(192, 192, 192),
	Label = "Fog Color",
	Callback = function(self, Value)
		fogColor = Value
		if fogEnabled then
			game.Lighting.FogColor = Value
		end
	end
})

-- Fog Start Distance
WorldTab:SliderInt({
	Label = "Fog Start Distance",
	Value = 0,
	Minimum = 0,
	Maximum = 1000,
	Callback = function(self, Value)
		fogStartValue = Value
		if fogEnabled then
			game.Lighting.FogStart = Value
		end
		print("Fog Start set to: " .. Value)
	end
})

-- Fog End Distance
WorldTab:SliderInt({
	Label = "Fog End Distance",
	Value = 100,
	Minimum = 10,
	Maximum = 10000,
	Callback = function(self, Value)
		fogEndValue = Value
		if fogEnabled then
			game.Lighting.FogEnd = Value
		end
		print("Fog End set to: " .. Value)
	end
})

-- Saturation
WorldTab:SliderInt({
	Label = "Saturation",
	Value = 0,
	Minimum = -100,
	Maximum = 100,
	Callback = function(self, Value)
		local colorCorrection = game.Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", game.Lighting)
		colorCorrection.Saturation = Value / 100
		print("Saturation set to: " .. Value)
	end
})

-- Contrast
WorldTab:SliderInt({
	Label = "Contrast",
	Value = 0,
	Minimum = -100,
	Maximum = 100,
	Callback = function(self, Value)
		local colorCorrection = game.Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", game.Lighting)
		colorCorrection.Contrast = Value / 100
		print("Contrast set to: " .. Value)
	end
})

-- Brightness
WorldTab:SliderInt({
	Label = "Brightness",
	Value = 0,
	Minimum = -100,
	Maximum = 100,
	Callback = function(self, Value)
		local colorCorrection = game.Lighting:FindFirstChildOfClass("ColorCorrectionEffect") or Instance.new("ColorCorrectionEffect", game.Lighting)
		colorCorrection.Brightness = Value / 100
		print("Brightness set to: " .. Value)
	end
})

-- Skybox Changer
WorldTab:Combo({
	Value = "Default",
	Label = "Skybox",
	Items = {"Default", "Space", "Twilight", "Sunset", "Night"},
	Callback = function(self, Value)
		skyboxSetting = Value
		local skybox = game.Lighting:FindFirstChildOfClass("Sky") or Instance.new("Sky", game.Lighting)
		
		if Value == "Default" then
			skybox.SkyboxBk = "rbxassetid://7018684000"
			skybox.SkyboxDn = "rbxassetid://7018684000"
			skybox.SkyboxFt = "rbxassetid://7018684000"
			skybox.SkyboxLf = "rbxassetid://7018684000"
			skybox.SkyboxRt = "rbxassetid://7018684000"
			skybox.SkyboxUp = "rbxassetid://7018684000"
		elseif Value == "Space" then
			skybox.SkyboxBk = "rbxassetid://149397692"
			skybox.SkyboxDn = "rbxassetid://149397686"
			skybox.SkyboxFt = "rbxassetid://149397697"
			skybox.SkyboxLf = "rbxassetid://149397684"
			skybox.SkyboxRt = "rbxassetid://149397688"
			skybox.SkyboxUp = "rbxassetid://149397702"
		elseif Value == "Twilight" then
			skybox.SkyboxBk = "rbxassetid://264908339"
			skybox.SkyboxDn = "rbxassetid://264907909"
			skybox.SkyboxFt = "rbxassetid://264909420"
			skybox.SkyboxLf = "rbxassetid://264909758"
			skybox.SkyboxRt = "rbxassetid://264908886"
			skybox.SkyboxUp = "rbxassetid://264907379"
		elseif Value == "Sunset" then
			skybox.SkyboxBk = "rbxassetid://323494035"
			skybox.SkyboxDn = "rbxassetid://323494368"
			skybox.SkyboxFt = "rbxassetid://323494130"
			skybox.SkyboxLf = "rbxassetid://323494252"
			skybox.SkyboxRt = "rbxassetid://323494067"
			skybox.SkyboxUp = "rbxassetid://323493360"
		elseif Value == "Night" then
			skybox.SkyboxBk = "rbxassetid://12064107"
			skybox.SkyboxDn = "rbxassetid://12064152"
			skybox.SkyboxFt = "rbxassetid://12064121"
			skybox.SkyboxLf = "rbxassetid://12063984"
			skybox.SkyboxRt = "rbxassetid://12064115"
			skybox.SkyboxUp = "rbxassetid://12064131"
		end
	end
})

local ColorsTab = Window:CreateTab({Name="Colors"})

ColorsTab:Label({
	Text = "ESP Settings"
})
-- ESP Color Picker
ColorsTab:DragColor3({
	Value = Color3.fromRGB(255, 255, 255),
	Label = "Box ESP Color",
	Callback = function(self, Value)
		espColor = Value
	end
})

-- Name ESP Color Picker
ColorsTab:DragColor3({
	Value = Color3.fromRGB(255, 255, 255),
	Label = "Name ESP Color",
	Callback = function(self, Value)
		nameEspColor = Value -- This now correctly updates the nameEspColor variable
	end
})

-- Healthbar Color Picker (Full Health)
ColorsTab:DragColor3({
	Value = Color3.fromRGB(0, 255, 0),
	Label = "Full Health Color",
	Callback = function(self, Value)
		healthbarColor = Value
	end
})

-- Healthbar Color Picker (Low Health)
ColorsTab:DragColor3({
	Value = Color3.fromRGB(255, 0, 0),
	Label = "Low Health Color",
	Callback = function(self, Value)
		lowHealthColor = Value
	end
})

-- Skeleton ESP Color Picker
ColorsTab:DragColor3({
	Value = Color3.fromRGB(255, 255, 255),
	Label = "Skeleton ESP Color",
	Callback = function(self, Value)
		skeletonColor = Value
	end
})

-- Chams Color Picker
ColorsTab:DragColor3({
	Value = Color3.fromRGB(0, 170, 255),
	Label = "Chams Color",
	Callback = function(self, Value)
		chamsColor = Value
	end
})



-- Menu Tab
local MenuTab = Window:CreateTab({Name="Menu Settings"})

MenuTab:Label({
	Text = "Menu Settings"
})

-- Watermark variables
local watermarkText = "core.cc"
local watermarkColor = Color3.fromRGB(0, 170, 255)
local watermarkTransparency = 0.8
local watermarkPosition = Vector2.new(10, 10)
local showWatermark = true

-- Create watermark drawing objects
local watermarkBackground = Drawing.new("Square")
watermarkBackground.Size = Vector2.new(150, 25)
watermarkBackground.Position = watermarkPosition
watermarkBackground.Color = Color3.fromRGB(30, 30, 30)
watermarkBackground.Filled = true
watermarkBackground.Transparency = watermarkTransparency
watermarkBackground.Visible = showWatermark
watermarkBackground.ZIndex = 1

local watermarkAccent = Drawing.new("Square")
watermarkAccent.Size = Vector2.new(2, 25)
watermarkAccent.Position = watermarkPosition
watermarkAccent.Color = watermarkColor
watermarkAccent.Filled = true
watermarkAccent.Transparency = 1
watermarkAccent.Visible = showWatermark
watermarkAccent.ZIndex = 3

local watermarkLabel = Drawing.new("Text")
watermarkLabel.Text = watermarkText
watermarkLabel.Position = Vector2.new(watermarkPosition.X + 10, watermarkPosition.Y + 5)
watermarkLabel.Color = Color3.fromRGB(255, 255, 255)
watermarkLabel.Size = 16
watermarkLabel.Font = 2 -- Enum.Font.SourceSansBold
watermarkLabel.Center = false
watermarkLabel.Outline = false
watermarkLabel.Transparency = 1
watermarkLabel.Visible = showWatermark
watermarkLabel.ZIndex = 2

-- Function to update watermark
local function updateWatermark()
    local fps = math.floor(1/game:GetService("RunService").RenderStepped:Wait())
    local ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
    local timeString = os.date("%H:%M:%S")
    
    watermarkLabel.Text = string.format("%s | FPS: %d | Ping: %dms | %s", watermarkText, fps, ping, timeString)
    
    -- Adjust background width based on text size
    local textBounds = watermarkLabel.TextBounds
    watermarkBackground.Size = Vector2.new(textBounds.X + 20, 25)
end

-- Update watermark in a loop
spawn(function()
    while wait(0.5) do
        if showWatermark then
            updateWatermark()
        end
    end
end)

-- Watermark Toggle
MenuTab:Checkbox({
    Value = true,
    Label = "Show Watermark",
    Callback = function(self, Value)
        showWatermark = Value
        watermarkBackground.Visible = Value
        watermarkAccent.Visible = Value
        watermarkLabel.Visible = Value
    end
})

-- Watermark Color Picker
MenuTab:DragColor3({
    Value = watermarkColor,
    Label = "Watermark Accent Color",
    Callback = function(self, Value)
        watermarkColor = Value
        watermarkAccent.Color = Value
    end
})

-- Watermark Position
MenuTab:Label({
    Text = "Watermark Position"
})

MenuTab:SliderInt({
    Label = "X Position",
    Value = watermarkPosition.X,
    Minimum = 0,
    Maximum = 1000,
    Callback = function(self, Value)
        watermarkPosition = Vector2.new(Value, watermarkPosition.Y)
        watermarkBackground.Position = watermarkPosition
        watermarkAccent.Position = watermarkPosition
        watermarkLabel.Position = Vector2.new(watermarkPosition.X + 10, watermarkPosition.Y + 5)
    end
})

MenuTab:SliderInt({
    Label = "Y Position",
    Value = watermarkPosition.Y,
    Minimum = 0,
    Maximum = 1000,
    Callback = function(self, Value)
        watermarkPosition = Vector2.new(watermarkPosition.X, Value)
        watermarkBackground.Position = watermarkPosition
        watermarkAccent.Position = watermarkPosition
        watermarkLabel.Position = Vector2.new(watermarkPosition.X + 10, watermarkPosition.Y + 5)
    end
})
